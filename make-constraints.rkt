#lang racket
(require (only-in "micro-w-constraints.rkt" var? call/initial-state-maker))
(provide (all-defined-out))
(define (ext-s x v s) 
  (if (occurs? x v s) #f `((,x . ,v) . ,s)))
(define (occurs? x v s)
  (let ((v (walk v s)))
    (cond
      ((var? v) (eqv? x v))
      ((pair? v) (or (occurs? x (car v) s)
                     (occurs? x (cdr v) s)))
      (else #f))))
(define (walk u s)
  (let ((pr (assv u s)))
    (if pr (walk (cdr pr) s) u)))
(define (unify u v s)
  (let ((u (walk u s)) (v (walk v s)))
    (cond
      ((eqv? u v) s)
      ((var? u) (ext-s u v s))
      ((var? v) (ext-s v u s))
      ((and (pair? u) (pair? v))
       (let ((s (unify (car u) (car v) s)))
         (and s (unify (cdr u) (cdr v) s))))
      (else #f))))
(define (valid-s? s)
  (foldr 
    (lambda (pr s) 
      (and s (unify (car pr) (cdr pr) s)))
    '() 
    s))
(define-syntax make-constraint
  (syntax-rules ()
    ((_ name u v ...)
     (define (name u v ...)
       (lambda (s/c)
         (let ((s (hash-update (car s/c) 'name ((curry cons) (list* u v ...)))))
           (return `(,s  . ,(cdr s/c)))))))))
(define call/initial-state 
  (call/initial-state-maker 
    (make-immutable-hasheqv 
      (map list '(not-pairo listo symbolo == =/= absento booleano)))))
(make-constraint symbolo u)
(make-constraint not-pairo u)
(make-constraint listo u)
(make-constraint == u v)
(make-constraint =/= u v)
(make-constraint booleano u)
(make-constraint absento u v)
(define (invalid-d? d)
  (lambda (w)
    (ormap 
     (lambda (pr) 
       (equal? (unify (car pr) (cdr pr) w) w))
     d)))
(define (invalid-a? a)
  (lambda (w)
    (ormap 
     (lambda (pr)
       (mem? (car pr) (cdr pr) w))
     a)))
(define (invalid-y? y)
  (lambda (w)
    (ormap
     (lambda (y)
       (let ((t (walk y w)))
         (and (not (symbol? t))
              (not (var? t)))))
     y)))
(define (invalid-n? n)
  (lambda (w)
    (ormap
     (lambda (n) 
       (pair? (walk n w)))
     n)))
(define (invalid-l1? p y)
  (lambda (w)
    (ormap 
     (lambda (p)
       (let ((end (walk-to-end p w)))
         (ormap (lambda (y) (equal? (unify y end w) w)) y)))
     p)))
(define (invalid-l2? p b)
  (lambda (w)
    (ormap 
     (lambda (p)
       (let ((end (walk-to-end p w)))
         (ormap (lambda (b) (equal? (unify b end w) w)) b)))
     p)))
(define (invalid-l3? p n d a)
  (lambda (w)
    (ormap 
     (lambda (p)
       (let ((end (walk-to-end p w)))
         (let ((w^ (unify end '() w)))
           (and w^
                (ormap (lambda (n) (equal? (unify end n w) w)) n)
                (or (ormap (lambda (pr) (equal? (unify (car pr) (cdr pr) w^) w^)) d)
                    (ormap (lambda (pr) (mem? (car pr) (cdr pr) w^)) a))))))
     p)))
(define (invalid-l4? p a)
  (lambda (w)
    (ormap 
     (lambda (p)
       (let ((end (walk-to-end p w)))
         (ormap
          (lambda (pr) (and (null? (walk (car pr) w)) (mem? end (cdr pr) w)))
          a)))
     p)))
(define (invalid-b1? b)
  (lambda (s)
    (ormap
      (lambda (b)
        (let ((b (walk b s)))
          (not (or (var? b) (boolean? b)))))
      b)))
(define (invalid-b2? b y)
  (lambda (s)
    (ormap
     (lambda (b)
       (ormap 
         (lambda (y)
           (equal? (unify y b s) s))
         y))
     b)))
(define (invalid-b3? b d a)
  (lambda (s)
    (ormap
      (lambda (b)
        (let ((not-b 
               (lambda (s^)
                 (and 
                  s^
                  (or
                   (ormap 
                    (lambda (pr)
                      (equal? (unify (car pr) (cdr pr) s^) s^))
                    d)
                   (ormap 
                    (lambda (pr) 
                      (mem? (car pr) (cdr pr) s^))
                    a))))))
          (and (not-b (unify b #t s))
               (not-b (unify b #f s)))))
      b)))
(define (return s/c)
  (if (consistent? (car s/c))
      '()
      (list s/c)))
(define (consistent? st)
  (let ((== (hash-ref st '==)))
    (let ((=/= (hash-ref st '=/=))
          (absento (hash-ref st 'absento))
          (symbolo (hash-ref st 'symbolo))
          (not-pairo (hash-ref st 'not-pairo))
          (listo (hash-ref st 'listo))
          (booleano (hash-ref st 'booleano)))
      (cond
        ((valid-s? ==) 
         => (lambda (s)
              (or ((invalid-d? =/=) s)
                  ((invalid-a? absento) s)
                  ((invalid-y? symbolo) s)
                  ((invalid-n? not-pairo) s)
                  ((invalid-l1? listo symbolo) s)
                  ((invalid-l2? listo booleano) s)
                  ((invalid-l3? listo not-pairo =/= absento) s)
                  ((invalid-l4? listo absento) s)
                  ((invalid-b1? booleano) s)
                  ((invalid-b2? booleano symbolo) s)
                  ((invalid-b3? booleano =/= absento) s))))
        (else #t)))))
(define (mem? u v s)
  (let ((v (walk v s)))
    (or (equal? (unify u v s) s)
        (and (pair? v)
             (or (mem? u (car v) s)
                 (mem? u (cdr v) s))))))
(define (walk-to-end x s)
  (let ((x (walk x s)))
    (cond
      ((var? x) x)
      ((pair? x) (walk-to-end (cdr x) s))
      (else x))))
(define-syntax-rule 
  (define-goal-constructor (name . args) body)
  (define (((name . args) s/c)) (body s/c)))
